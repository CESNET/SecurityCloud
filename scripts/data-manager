#!/usr/bin/env python3

# author: Jan Wrona, wrona@cesnet.cz

# Copyright (C) 2017 CESNET
#
# LICENSE TERMS
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
# 3. Neither the name of the Company nor the names of its contributors
#    may be used to endorse or promote products derived from this
#    software without specific prior written permission.
#
# ALTERNATIVELY, provided that this notice is retained in full, this
# product may be distributed under the terms of the GNU General Public
# License (GPL) version 2 or later, in which case the provisions
# of the GPL apply INSTEAD OF those given above.
#
# This software is provided ``as is'', and any express or implied
# warranties, including, but not limited to, the implied warranties of
# merchantability and fitness for a particular purpose are disclaimed.
# In no event shall the company or contributors be liable for any
# direct, indirect, incidental, special, exemplary, or consequential
# damages (including, but not limited to, procurement of substitute
# goods or services; loss of use, data, or profits; or business
# interruption) however caused and on any theory of liability, whether
# in contract, strict liability, or tort (including negligence or
# otherwise) arising in any way out of the use of this software, even
# if advised of the possibility of such damage.


import os
import sys
import re
import argparse
import datetime
import warnings
from pathlib import Path


OUTPUT_PREFIX = os.path.basename(__file__).upper() if '__file__' in globals() \
    else 'DATA-MANAGER'

DU_UPPER_BOUND_LIMIT = 95.0
DU_LOWER_BOUND_LIMIT = 5.0
DU_BOUND_DIFFERENCE_LIMIT = 10.0

# strftime()/strptime() translation table
STRTIME_DICT = {'year': '%Y', 'month': '%m', 'day': '%d', 'hour': '%H',
                'minute': '%M', 'second': '%S'}
# strftime()/strptime() formats for YYYYMMDDHHMM and YYYYMMDDHHMMSS
STRTIME_FORMAT_YMDHM = (STRTIME_DICT['year'] + STRTIME_DICT['month']
                        + STRTIME_DICT['day'] + STRTIME_DICT['hour']
                        + STRTIME_DICT['minute'])
STRTIME_FORMAT_YMDHMS = STRTIME_FORMAT_YMDHM + STRTIME_DICT['second']
# re match pattern for YYYYMMDDHHMM or YYYYMMDDHHMMSS
DATETIME_PATTERN = (r'(?P<year>\d{4})(?P<month>\d{2})(?P<day>\d{2})'
                    r'(?P<hour>\d{2})(?P<minute>\d{2})'
                    r'(?P<second>\d{2})?')
# precompiled regex for YYYYMMDDHHMM or YYYYMMDDHHMMSS
DATETIME_REGEX = re.compile(DATETIME_PATTERN, re.ASCII)


###############################################################################
class Node:
    """Representation of a node with multiple base profiles.

    In the usual case, list of base profiles contains just a single base
    profile called "live".
    """

    def __init__(self, path):
        self.path = path
        self.profiles = []

    def __repr__(self):
        return '{}(name={}, profiles={})'.format(type(self).__name__,
                                                 self.path.name, self.profiles)

    def scan(self):
        """Scan node's base directory and look for base profiles.

        Scan node's base directory, look for profiles and eventually
        recursively construct those profiles as instances of class Profile.
        """

        self.profiles.clear()

        for profile_dir in dir_scan(self.path, 'node'):
            profile = Profile(profile_dir, self)
            profile.scan()
            self.profiles.append(profile)


class Profile:
    """IPFIXcol profile/subprofile representation."""

    def __init__(self, path, parent):
        self.path = path  # pathlib path to the profile's base directory
        self.parent = parent  # profile's parent Profile or Node
        self.channels = []  # list of instances of Channel
        self.subprofiles = []  # list of instances of Profile

    def __repr__(self):
        return '{}(name={}, parent={}, channels={}, subprofiles={})'\
            .format(type(self).__name__, self.path.name, self.parent.path.name,
                    self.channels, self.subprofiles)

    def scan(self):
        """Scan profile's base directory and look for channels and subprofiles.

        Scan profile's base directory and look for for channels (directory
        "channels"), ignore directory with RRD files "rrd", also ignore hidden
        directories. All other directories are assumed to be subprofiles and
        are recursively constructed as instances of class Profile.
        """

        self.channels.clear()
        self.subprofiles.clear()

        # subprofiles and channels are alphabetically sorted due to lists
        # equality comaprison
        for subdir in sorted(dir_scan(self.path, 'profile')):
            vprint('profile "{}":'.format(self.path.name), end=' ')
            if subdir.name == 'channels':
                vprint('adding channels', use_prefix=False)
                for channel_dir in sorted(dir_scan(subdir, 'profile/channel')):
                    channel = self.Channel(channel_dir, self)
                    channel.scan()
                    self.channels.append(channel)
            elif subdir.name == 'rrd':
                vprint('ignoring RRD directory', use_prefix=False)
            else:
                vprint('adding subprofile "{}"'.format(subdir.name),
                       use_prefix=False)
                profile = Profile(subdir, self)
                profile.scan()
                self.subprofiles.append(profile)

        if not self.channels:
            raise Exception('profile "{}" is missing the "channels" directory'
                            .format(self.path.name))

    def get_channels(self, recursively=False):
        """Return a list of subprofiles, recursively or not."""

        channels = list(self.channels)  # make a copy
        if recursively:
            for subprofile in self.subprofiles:
                channels += subprofile.get_channels(recursively)
        return channels

    class Channel:
        """IPFIXcol channel representation."""

        def __init__(self, path, parent):
            self.path = path  # pathlib path to the channel's base directory
            self.parent = parent  # channel's parent Profile
            self.flow_files = []  # list of instances of FlowFile

        def __repr__(self):
            return ('{}(name={}, parent={}, earliest_flow_file={}, '
                    'latest_flow_file={})'
                    .format(type(self).__name__, self.path.name,
                            self.parent.path.name,
                            self.get_earliest_flow_file(),
                            self.get_latest_flow_file()))

        def is_empty(self):
            return False if self.flow_files else True

        def get_earliest_flow_file(self):
            return self.flow_files[0] if not self.is_empty() else None

        def get_latest_flow_file(self):
            return self.flow_files[-1] if not self.is_empty() else None

        def unlink_earliest_flow_file(self):
            if args.dry_run:
                earliest_ff = self.get_earliest_flow_file()  # only retrieves
                print('would unlink "{}"'.format(earliest_ff.path))
            else:
                earliest_ff = self.flow_files.pop(0)  # retrieves and removes
                vprint('unlinking "{}"'.format(earliest_ff.path))
                earliest_ff.path.unlink()
            self.remove_empty_parent_directories(earliest_ff)

        def remove_empty_parent_directories(self, flow_file):
            """Only works with YYYY/MM/DD directory hierarchy."""

            if flow_file.name_datetime.date() != flow_file.path_date:
                warnings.warn('remove empty parent directories: "{}": '
                              'path/name date mismatch, unable to remove '
                              'empty directories'.format(flow_file.path))
                return

            parent_dir = flow_file.path.parent
            for i in ['day', 'month', 'year']:
                if dir_is_empty(parent_dir):
                    if args.dry_run:
                        print('would remove empty {} directory "{}"'
                              .format(i, parent_dir))
                    else:
                        vprint('removing empty {} directory "{}"'
                               .format(i, parent_dir))
                        parent_dir.rmdir()
                else:
                    break
                parent_dir = parent_dir.parent

        def scan(self):
            """Scan channel's base directory and look for flow files."""

            self.flow_files.clear()

            for path in self.path.rglob('*'):
                if not path.is_file():
                    continue
                elif path.name.startswith('.'):
                    warnings.warn('channel scan: found invalid file "{}" '
                                  'in "{}" channel storage hierarchy, skipping'
                                  .format(path, self.path.name))

                flow_file = self.FlowFile(path, self)
                try:
                    flow_file.parse_path()
                except ValueError as e:
                    warnings.warn(e.args[0] + ', skipping')
                    continue

                self.flow_files.append(flow_file)
            self.flow_files.sort(key=lambda flow_file: flow_file.name_datetime)

        class FlowFile:
            """Flow file representation."""

            def __init__(self, path, parent):
                self.path = path  # pathlib path to the file
                self.parent = parent  # file's parent Channel
                self.name_datetime = None
                self.path_date = None

            def __repr__(self):
                return ('{}(name={}, parent={}, name_datetime={}, '
                        'path_date={})'.format(type(self).__name__,
                                               self.path.name,
                                               self.parent.path.name,
                                               self.name_datetime,
                                               self.path_date))

            def __lt__(self, other):
                return self.name_datetime < other.name_datetime

            def __le__(self, other):
                return self.name_datetime <= other.name_datetime

            def __eq__(self, other):
                return self.name_datetime == other.name_datetime

            def __gt__(self, other):
                return self.name_datetime > other.name_datetime

            def __ge__(self, other):
                return self.name_datetime >= other.name_datetime

            def parse_path(self):
                """Discover date and time from file's path.

                Search for patterns YYYYMMDDHHMM or YYYYMMDDHHMMSS in the
                file's name and if found, convert the match into corresponding
                datetime object. Then check if file's directory hierarchy
                comply with YYYY/MM/DD format.
                """

                match = DATETIME_REGEX.search(self.path.name)
                if not match:
                    raise ValueError('flow file parse path: patterns '
                                     'YYYYMMDDHHMM or YYYYMMDDHHMMSS not '
                                     'found in file\'s "{}" name'
                                     .format(self.path))

                if match.group('second'):
                    strtime_format = STRTIME_FORMAT_YMDHMS
                else:
                    strtime_format = STRTIME_FORMAT_YMDHM
                self.name_datetime = datetime.datetime.strptime(match.group(0),
                                                                strtime_format)
                try:
                    day = int(self.path.parent.name)
                    month = int(self.path.parent.parent.name)
                    year = int(self.path.parent.parent.parent.name)
                    self.path_date = datetime.date(year, month, day)
                except Exception:
                    warnings.warn('flow file parse path: "{}" does not comply '
                                  'with YYYY/MM/DD directory hierarchy'
                                  .format(self.path))
                if self.name_datetime.date() != self.path_date:
                    warnings.warn('flow file parse path: path/name date '
                                  'mismatch, name corresponds to "{}", path '
                                  'corresponds to "{}"'
                                  .format(self.name_datetime, self.path_date))


###############################################################################
def vprint_formatter(*args, **kwargs):
    """Verbose-enabled print formatter."""
    if 'use_prefix' in kwargs:
        use_prefix = kwargs['use_prefix']
        del(kwargs['use_prefix'])
    else:
        use_prefix = True

    if use_prefix:
        print(OUTPUT_PREFIX, 'VERBOSE:', *args, **kwargs)
    else:
        print(*args, **kwargs)


def vprint_formatter_void(*args, **kwargs):
    """Verbose-disabled print formatter."""
    pass


def myformatwarning(message, category, filename, lineno, line=None):
    return '{} WARNING: {}\n'.format(OUTPUT_PREFIX, str(message))


###############################################################################
def main():
    rc = 0

    # check if used disk space is below the given upper bound
    du_before = disk_usage(base_path, output='percentual')
    if du_before < args.du_upper_bound:
        vprint('nothing to do, used disk space is below the given upper bound '
               '({:.2f} % < {:.2f} %)'.format(du_before, args.du_upper_bound))
        return 0

    # find node directories in the base path
    node_dirs = dir_scan(base_path, 'base')
    if not node_dirs:
        raise Exception('node directory lookup: nothing appropriate found in '
                        'the given directory')

    # check if all node directories are placed on the same device
    ref_st_dev = node_dirs[0].stat().st_dev
    if not all(ref_st_dev == node_dir.stat().st_dev for node_dir in node_dirs):
        raise Exception('node directory lookup: one or more node directories '
                        'are placed on different devices')

    # scan all node directories and create profiles, recursively
    nodes = []
    for path in node_dirs:
        node = Node(path)
        node.scan()
        nodes.append(node)

    # get list of all channels, recursively
    all_channels = []
    for node in nodes:
        for profile in node.profiles:
            all_channels += profile.get_channels(recursively=True)

    total_unlinked = 0
    if args.du_lower_bound:
        vprint('lower bound defined, using hysteresis')
        while disk_usage(base_path) > args.du_lower_bound:
            unlinked = unlink_earliest_files(all_channels)
            if unlinked == 0:
                warnings.warn('all channels are empty, cannot reach lower '
                              'bound')
                rc = 1
            total_unlinked += unlinked
    else:
        vprint('lower bound not defined, removing only the oldest files')
        total_unlinked = unlink_earliest_files(all_channels)
        if total_unlinked == 0:
            warnings.warn('all channels are empty, nothing to do')

    du_after = disk_usage(base_path, output='percentual')
    vprint('summary: unlinked {} files, disk usage went from {:.2f} % to '
           '{:.2f} %'.format(total_unlinked, du_before, du_after))

    return rc


def disk_usage(path, output='percentual'):
    """
    Return the amount of disk space used on the file system containing given
    path.

    statvfs.f_blocks is size of fs in f_frsize units
    statvfs.f_bavail is number of free blocks for unprivileged users
    """

    statvfs = os.statvfs(path)
    used_blocks = statvfs.f_blocks - statvfs.f_bavail
    if output == 'blocks':
        return used_blocks
    elif output == 'bytes':
        return used_blocks * statvfs.f_frsize
    elif output == 'percentual':
        return used_blocks / statvfs.f_blocks * 100.0
    else:
        raise ValueError('invalid value of output "{}", possible options are '
                         'blocks, bytes, and percentual'.format(output))


def dir_scan(path, vprefix):
    """
    Wrapper for Path.iterdir(), which returns list containing only directories,
    ignores hidden files, and uses vprint().
    """
    ret = []
    vprint('{} directory "{}" scan:'.format(vprefix, path.name))
    for file in path.iterdir():
        if not file.is_dir():
            vprint('\tignoring "{}", not a directory'.format(file.name))
        elif file.name.startswith('.'):
            vprint('\tignoring hidden directory "{}"'.format(file.name))
        else:
            vprint('\tfound directory "{}"'.format(file.name))
            ret.append(file)
    return ret


def dir_is_empty(path):
    return not any(True for _ in path.iterdir())


def min_all(iterable, selector):
        """Return list of all smallest items in an iterable."""
        smallest = min(iterable, key=selector)
        smallest_selected = selector(smallest)
        return [i for i in iterable if selector(i) == smallest_selected]


def unlink_earliest_files(channels):
    non_empty_channels = [ch for ch in channels if not ch.is_empty()]
    if not non_empty_channels:
        return 0

    min_channels = min_all(non_empty_channels, lambda channel:
                           channel.get_earliest_flow_file())

    vprint('going to unlink {} files from {}'
           .format(len(min_channels),
                   min_channels[0].get_earliest_flow_file().name_datetime))

    du_before = (disk_usage(base_path, output='bytes'),
                 disk_usage(base_path, output='percentual'))

    size_all = 0  # size of all unlinked files in bytes
    for channel in min_channels:
        size_all += os.stat(channel.get_earliest_flow_file().path).st_size
        channel.unlink_earliest_flow_file()

    du_after = (disk_usage(base_path, output='bytes'),
                disk_usage(base_path, output='percentual'))
    vprint('used disk space in bytes: '
           'before = {} ({:.2f} %), '
           'after = {} ({:.2f} %), '
           'difference = {}, '
           'unlinked files\' size = {}'
           .format(du_before[0], du_before[1],
                   du_after[0], du_after[1],
                   abs(du_before[0] - du_after[0]),
                   size_all))
    return len(min_channels)


###############################################################################
if __name__ == "__main__":
    # set my format for warning print function
    warnings.formatwarning = myformatwarning

    ########################################
    # parse command line arguments
    parser = argparse.ArgumentParser(
        description='Flow file data manager.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('-u', '--du-upper-bound',
                        dest='du_upper_bound',
                        type=float,
                        default=90.0,
                        help='Percentual upper bound of disk usage.')
    parser.add_argument('-l', '--du-lower-bound',
                        dest='du_lower_bound',
                        type=float,
                        default=None,
                        help='Percentual lower bound of disk usage.')
    parser.add_argument('-n', '--dry-run',
                        dest='dry_run',
                        action='store_true',
                        default=False,
                        help='Don\'t actually remove anything, just show what '
                             'would be done.')
    parser.add_argument('-v', '--verbose',
                        dest='verbose',
                        action='store_true',
                        default=False,
                        help='Be verbose.')

    parser.add_argument('base_path',
                        nargs=1,
                        help='Path to the flow storage directory.')
    args = parser.parse_args()

    ########################################
    # validate and handle command line arguments
    # define verbose print function
    vprint = vprint_formatter if args.verbose else vprint_formatter_void

    # check validity of given bounds
    if args.du_lower_bound and args.du_lower_bound > args.du_upper_bound:
        raise ValueError('the lower bound is greater than the upper bound')
    if (args.du_lower_bound and args.du_upper_bound - args.du_lower_bound >
            DU_BOUND_DIFFERENCE_LIMIT):
        raise ValueError('the lower and upper bound difference is dangerously '
                         'large')
    if args.du_upper_bound > DU_UPPER_BOUND_LIMIT:
        raise ValueError('the upper bound is dangerously high')
    if args.du_lower_bound and args.du_lower_bound < DU_LOWER_BOUND_LIMIT:
        raise ValueError('the lower bound is dangerously low')

    # check validity of given base path
    base_path = Path(args.base_path[0])
    if not base_path.exists():
        raise FileNotFoundError('"{}" does not exist'.format(base_path))
    if not base_path.is_dir():
        raise NotADirectoryError('"{}" does not point to a directory'
                                 .format(base_path))

    ########################################
    # do the real work
    sys.exit(main())
